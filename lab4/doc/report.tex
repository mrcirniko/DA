\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: строковые алгоритмы}

Выполнил студент группы М80-208Б-22 МАИ \textit{Цирулев Николай}.

\subsection*{Условие}

Необходимо реализовать поиск одного образца в тексте с использованием алгоритма Z-блоков. Алфавит — строчные латинские буквы. 
\begin{itemize}
\item
    Формат ввода:
    
    На первой строке входного файла текст, на следующей — образец. Образец и текст помещаются в оперативной памяти.

\item
    Формат вывода:
    
    В выходной файл нужно вывести информацию о всех позициях текста, начиная с которых встретились вхождения образца. Выводить следует по одной позиции на строчке, нумерация позиций в тексте начинается с 0. 
\end{itemize}

\subsection*{Метод решения}

Для поиска образца в тексте необходимо было реализовать алгоритм Z-блоков. Сначала строка образца и текста объединяются, и для каждой позиции вычисляется Z-строка, описывающая длину наибольшего префикса строки, совпадающего с подстрокой, начинающейся в данной позиции. После этого, анализируя Z-строку, программа находит индексы в тексте, где образец встретился, выводя их на экран.

\subsection*{Описание программы}

Исходный код программы содержится в файле main.cpp. Для хранения входных данных (образца и текста) используется контейнер стандартной библиотеки C++ \texttt{std::string}. Для хранения Z-строки был выбран \texttt{std::vector}.

Первая строчка \texttt{main} отключает синхронизацию потоков ввода-вывода. Вторая отвязывает стандартный поток ввода от стандартного потока вывода, блягодаря чему при каждом вызове \texttt{std::cin} не сбрасывается буфер. Обе эти строчки позволяют значительно ускорить ввод-вывод в программе.

Далее программа считывает строки и объединяет их в одну. \texttt{z\_algorithm()} вычисляет Z-строку используя алгоритм Z-блоков. Далее остается пройтись по полученной Z-строке и вывести индексы элементов, значение которых больше или равно длине образца.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>

std::vector<long long> z_algorithm(std::string s) {
    long long n = (long long) s.size();
    std::vector<long long> z(n, 0);
    long long l = 0, r = 0;
    for (long long i = 1; i < n; i++) {
        if (i <= r) {
            z[i] = std::min(z[i - l], r - i + 1);
        }

        while (i + z[i] < n && s[i + z[i]] == s[z[i]]) {
            ++z[i];
        }

        if (i + z[i] - 1 > r) {
            r = i + z[i] - 1;
            l = i;
        }
    }
    return z;
}

int main() {
    std::ios_base::sync_with_stdio(false);
	std::cin.tie(0);
    std::string s;
    std::string p;
    std::cin >> s;
    std::cin >> p;
    std::vector<long long> z = z_algorithm(p + s);
    long long n = p.size();
    for (long long i = 1; i < z.size(); ++i) {
        if (z[i] >= n && i - n >= 0) {
            std::cout << i - n << '\n';
        }
    }
}
\end{lstlisting}

\subsection*{Дневник отладки}

После отправки решения в чекер была обнаружена ошибка. В ходе ручного тестирования была выяснена причина ошибки: при выводе результата не было проверки на выход индекса за пределы массива вохдных данных:
\begin{itemize}
\item
    Строка программы с ошибкой:
    \begin{lstlisting}[language=C++]
            if (z[i] >= n) {
    \end{lstlisting}
\item
    Исправленная строка:
    \begin{lstlisting}[language=C++]
            if (z[i] >= n && i - n >= 0) {
    \end{lstlisting}
\end{itemize}

\subsection*{Тест производительности}
нада сделать

\subsection*{Выводы}

В ходе выполнения данной работы были изучены строковые алгоритмы, в частности алгоритм Z-блоков. 

\end{document}
